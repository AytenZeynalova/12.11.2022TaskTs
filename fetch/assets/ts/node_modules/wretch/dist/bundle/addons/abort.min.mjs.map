{"version":3,"file":"abort.min.mjs","sources":["../../../src/addons/abort.ts"],"sourcesContent":["import type { Wretch, WretchAddon, WretchErrorCallback, WretchResponseChain } from \"../types.js\"\n\nexport interface AbortWretch {\n  /**\n   * Associates a custom controller with the request.\n   *\n   * Useful when you need to use\n   * your own AbortController, otherwise wretch will create a new controller itself.\n   *\n   * ```js\n   * const controller = new AbortController()\n   *\n   * // Associates the same controller with multiple requests\n   * wretch(\"url1\")\n   *   .addon(AbortAddon())\n   *   .signal(controller)\n   *   .get()\n   *   .json()\n   * wretch(\"url2\")\n   *   .addon(AbortAddon())\n   *   .signal(controller)\n   *   .get()\n   *   .json()\n   *\n   * // Aborts both requests\n   * controller.abort()\n   * ```\n   *\n   * @param controller - An instance of AbortController\n   */\n  signal: <T extends AbortWretch, C, R>(this: T & Wretch<T, C, R>, controller: AbortController) => this\n}\n\nexport interface AbortResolver {\n  /**\n   * Aborts the request after a fixed time.\n   *\n   * If you use a custom AbortController associated with the request, pass it as the second argument.\n   *\n   * ```js\n   * // 1 second timeout\n   * wretch(\"...\").addon(AbortAddon()).get().setTimeout(1000).json(_ =>\n   *   // will not be called if the request timeouts\n   * )\n   * ```\n   *\n   * @param time - Time in milliseconds\n   * @param controller - An instance of AbortController\n   */\n  setTimeout: <T, C extends AbortResolver, R>(this: C & WretchResponseChain<T, C, R>, time: number, controller?: AbortController) => this\n  /**\n   * Returns the provided or generated AbortController plus the wretch response chain as a pair.\n   *\n   * ```js\n   * // We need the controller outside the chain\n   * const [c, w] = wretch(\"url\")\n   *   .addon(AbortAddon())\n   *   .get()\n   *   .controller()\n   *\n   * // Resume with the chain\n   * w.onAbort(_ => console.log(\"ouch\")).json()\n   *\n   * // Later onâ€¦\n   * c.abort()\n   * ```\n   */\n  controller: <T, C extends AbortResolver, R>(this: C & WretchResponseChain<T, C, R>) => [any, this]\n  /**\n   * Catches an AbortError and performs a callback.\n   */\n  onAbort: <T, C extends AbortResolver, R>(this: C & WretchResponseChain<T, C, R>, cb: WretchErrorCallback<T, C, R>) => this\n}\n\n/**\n * Adds the ability to abort requests using AbortController and signals under the hood.\n *\n *\n * _Only compatible with browsers that support\n * [AbortControllers](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).\n * Otherwise, you could use a (partial)\n * [polyfill](https://www.npmjs.com/package/abortcontroller-polyfill)._\n *\n * ```js\n * import AbortAddon from \"wretch/addons/abort\"\n *\n * const [c, w] = wretch(\"...\")\n *   .addon(AbortAddon())\n *   .get()\n *   .onAbort((_) => console.log(\"Aborted !\"))\n *   .controller();\n *\n * w.text((_) => console.log(\"should never be called\"));\n * c.abort();\n *\n * // Or :\n *\n * const controller = new AbortController();\n *\n * wretch(\"...\")\n *   .addon(AbortAddon())\n *   .signal(controller)\n *   .get()\n *   .onAbort((_) => console.log(\"Aborted !\"))\n *   .text((_) => console.log(\"should never be called\"));\n *\n * controller.abort();\n * ```\n */\nconst abort: () => WretchAddon<AbortWretch, AbortResolver> = () => {\n  let timeout = null\n  let fetchController = null\n  return {\n    beforeRequest(wretch, options) {\n      fetchController = wretch._config.polyfill(\"AbortController\", false, true)\n      if (!options[\"signal\"] && fetchController) {\n        options[\"signal\"] = fetchController.signal\n      }\n      timeout = {\n        ref: null,\n        clear() {\n          if (timeout.ref) {\n            clearTimeout(timeout.ref)\n            timeout.ref = null\n          }\n        }\n      }\n    },\n    wretch: {\n      signal(controller) {\n        return { ...this, _options: { ...this._options, signal: controller.signal } }\n      },\n    },\n    resolver: {\n      setTimeout(time, controller = fetchController) {\n        timeout.clear()\n        timeout.ref = setTimeout(() => controller.abort(), time)\n        return this\n      },\n      controller() { return [fetchController, this] },\n      onAbort(cb) { return this.error(\"AbortError\", cb) }\n    },\n  }\n}\n\nexport default abort\n"],"names":["abort","timeout","fetchController","beforeRequest","wretch","options","_config","polyfill","signal","ref","clear","clearTimeout","controller","this","_options","resolver","setTimeout","time","onAbort","cb","error"],"mappings":"AA6GM,MAAAA,EAAuD,KAC3D,IAAIC,EAAU,KACVC,EAAkB,KACtB,MAAO,CACLC,cAAcC,EAAQC,GACpBH,EAAkBE,EAAOE,QAAQC,SAAS,kBAAmB,EAAO,IAC/DF,EAAgB,QAAKH,IACxBG,EAAgB,OAAIH,EAAgBM,QAEtCP,EAAU,CACRQ,IAAK,KACLC,QACMT,EAAQQ,MACVE,aAAaV,EAAQQ,KACrBR,EAAQQ,IAAM,KAEjB,EAEJ,EACDL,OAAQ,CACNI,OAAOI,GACL,MAAO,IAAKC,KAAMC,SAAU,IAAKD,KAAKC,SAAUN,OAAQI,EAAWJ,QACpE,GAEHO,SAAU,CACRC,WAAWC,EAAML,EAAaV,GAG5B,OAFAD,EAAQS,QACRT,EAAQQ,IAAMO,YAAW,IAAMJ,EAAWZ,SAASiB,GAC5CJ,IACR,EACDD,aAAe,MAAO,CAACV,EAAiBW,KAAO,EAC/CK,QAAQC,GAAM,OAAON,KAAKO,MAAM,aAAcD,EAAK,GAEtD"}